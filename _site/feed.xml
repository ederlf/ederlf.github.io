<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/ederlm/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/ederlm/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-01-01T22:24:55+01:00</updated><id>http://localhost:4000/ederlm/feed.xml</id><title type="html">Lost in the twilight hall</title><subtitle>Eventual writings without any strong commitment 
</subtitle><entry><title type="html">Notes on UDP</title><link href="http://localhost:4000/ederlm/blog/2020/udp-notes/" rel="alternate" type="text/html" title="Notes on UDP" /><published>2020-10-26T16:12:00+01:00</published><updated>2020-10-26T16:12:00+01:00</updated><id>http://localhost:4000/ederlm/blog/2020/udp-notes</id><content type="html" xml:base="http://localhost:4000/ederlm/blog/2020/udp-notes/"><![CDATA[<p>UDP is commonly the target of jokes about how unreliable it is a transport protocol.</p>

<blockquote>
  <p><strong>“I could tell you a UDP joke. But I’m not sure you’ll get it.”</strong></p>
</blockquote>

<p>Indeed, the protocol is very simple and does not provide guarantees like TCP. Applications on top of UDP must implement functionalities such as error correction, flow and congestion control, sequencing, and duplication if they require a reliable transfer. So that is all?</p>

<p>Not really. After revisiting the UDP chapter in the first volume of <a href="https://www.pearson.com/us/higher-education/program/Fall-TCP-IP-Illustrated-Volume-1-The-Protocols-2nd-Edition/PGM69698.html">TCP/IP Illustrated</a>, I have found some details worth pinning in a post.</p>

<h2 id="udp-basics">UDP basics</h2>

<blockquote>
  <p>IP protocol number: <strong>17</strong></p>

  <p>UDP header size is always: <strong>8 bytes</strong></p>
</blockquote>

<p>All fields of the UDP header are <strong>2 bytes</strong> long.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="mi">0</span>                   <span class="mi">1</span>                   <span class="mi">2</span>                   <span class="mi">3</span>
 <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">0</span> <span class="mi">1</span>
<span class="o">-----------------------------------------------------------------</span>
<span class="o">|</span>          <span class="n">Source</span> <span class="n">Port</span>          <span class="o">|</span>        <span class="n">Destination</span> <span class="n">Port</span>       <span class="o">|</span>
<span class="o">-----------------------------------------------------------------</span>
<span class="o">|</span>             <span class="n">Length</span>            <span class="o">|</span>            <span class="n">Checksum</span>           <span class="o">|</span>
<span class="o">-----------------------------------------------------------------</span></code></pre></figure>

<h3 id="some-facts-about-the-header">Some facts about the header</h3>

<ul>
  <li>The source port is optional. I can be <strong>set to 0</strong> if the sender never requires a reply.</li>
  <li>The length field is the size of the header plus the payload. <strong>This field is redundant</strong>, because the IPv4 header already contains the total datagram size.</li>
  <li>A datagram with <strong>0 bytes of data</strong> is acceptable (but rare)</li>
  <li>The checksum field is <strong>optional with IPv4</strong>, but mandatory by <a href="https://tools.ietf.org/html/rfc1122">RFC1122</a>.</li>
</ul>

<h2 id="checksum">Checksum</h2>

<p>UDP is capable of providing error detection using the checksum field.</p>

<h3 id="some-facts-about-the-checksum">Some facts about the checksum</h3>

<ul>
  <li><strong>UDP pads odd-lenght datagrams with a 0 byte</strong> just for the computation and verifications</li>
  <li>Similarly to TCP, UDP <strong>uses a pseudo-header</strong> derived with fields from the IPv4 or IPv6 headers.
    <ul>
      <li>The pseudo-header is <strong>40 bytes</strong> long</li>
      <li>The pseudo-header includes the <strong>IP source and destination plus the protocol/ nextheader field</strong>.</li>
      <li>There is a <strong>0 padding before the protocol number</strong> in the pseudo-header</li>
      <li>Using IP layer fields lets the receiver <strong>verify if the datagram arrived at the correct destination</strong> (in a theoretical case that IP accepts wrongly accepts a packet to a different destination.)</li>
      <li>The pseudo-header is completed with the <strong>full UDP header and the data</strong>.</li>
    </ul>
  </li>
  <li>If the checksum is <strong>0x0000 on the receiver side</strong>, it indicates that the checksum was not computed.</li>
  <li>The UDP datagram is <strong>discarded silently</strong> in the case of errors</li>
</ul>

<p>When the packet goes through a <strong>NAT</strong>, the <strong>checksum is recalculated</strong> because the pseudo-header will have a different source IP.</p>

<h2 id="udp-and-ipv6">UDP and IPV6</h2>

<ul>
  <li>The checksum is <strong>mandatory for IPv6</strong>, because it does not calculate a checksum like IPv4.</li>
  <li>IPv6 supports <strong>jumbograms</strong> that are larger than <strong>65535 bytes</strong>. This value is larger than the Length field. When sending a jumbogram using UDP, the <strong>Length field is 0</strong></li>
  <li>The size of the UDP datagram for <strong>jumbograms</strong> is calculated using the <strong>Jumbo Payload Option</strong> (gives the length of the IPv6 payload)</li>
</ul>]]></content><author><name></name></author><category term="networks" /><category term="networks," /><category term="UDP," /><category term="protocols," /><category term="transport" /><summary type="html"><![CDATA[UDP is commonly the target of jokes about how unreliable it is a transport protocol.]]></summary></entry><entry><title type="html">Parsing the RTA_MULTIPATH attribute from Rtnetlink</title><link href="http://localhost:4000/ederlm/blog/2018/netlink-multipath/" rel="alternate" type="text/html" title="Parsing the RTA_MULTIPATH attribute from Rtnetlink" /><published>2018-01-25T16:12:00+01:00</published><updated>2018-01-25T16:12:00+01:00</updated><id>http://localhost:4000/ederlm/blog/2018/netlink-multipath</id><content type="html" xml:base="http://localhost:4000/ederlm/blog/2018/netlink-multipath/"><![CDATA[<p>I am developing an application that relies on the detection of changes to the Linux kernel route tables. For the job, one can use <a href="http://man7.org/linux/man-pages/man7/rtnetlink.7.html">Rtnetlink</a> for reading and modification of the routing tables. For example, the <em>RTM_NEWROUTE</em> message can be used to add a new route or read from the netlink socket, indicating a new route was added to the route table.</p>

<p>Netlink messages are usually composed of attributes which contain the information associated to the message type. For my use case, I need to obtain nexthop of new added routes. There are two attributes where next hops can be found:</p>

<ul>
  <li>
    <p>The usual attribute for the task is <em>RTA_GATEWAY</em> in a single route message. it is not hard to find <a href="https://gist.github.com/cl4u2/5204374#file-route_dump-c-L102">examples</a> for that case. The next hop data in that case is fairly simply too and points directly the value of the IP address of the next hop.</p>
  </li>
  <li>
    <p>The second case where next hop information is present is for the <em>RTA_MULTIPATH</em> attribute. Unfortunately, the information is not that straight forward and the available examples are not very simple. This post aims to be a simpler reference for anyone looking for the right way to parse <em>RTA_MULTIPATH</em>.</p>
  </li>
</ul>

<p>The example will consider <a href="https://gist.github.com/cl4u2/5204374#file-route_monitor-c-L59">this loop</a>. The idea is too add the case that handles <em>RTA_MULTIPATH</em>.</p>

<p>The data obtained from <em>RTA_MULTIPATH</em> is an array of <a href="https://elixir.bootlin.com/linux/v4.11/source/include/uapi/linux/rtnetlink.h#L339">struct rtnexthop</a>. While this struct describes all necessary information about next hops, it is not necessary to retrieve the data. For the task, rtnetlink provides macros to manipulate next hop information in the same fashion as messages.</p>

<p>The code below shows how the next hops can be retrieved.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">route_attribute</span><span class="o">-&gt;</span><span class="n">rta_type</span> <span class="o">==</span> <span class="n">RTA_MULTIPATH</span><span class="p">){</span>
    <span class="cm">/* Get RTA_MULTIPATH data */</span>
    <span class="k">struct</span> <span class="n">rtnexthop</span> <span class="o">*</span><span class="n">nhptr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rtnexthop</span><span class="o">*</span><span class="p">)</span> <span class="n">RTA_DATA</span><span class="p">(</span><span class="n">route_attribute</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">rtnhp_len</span> <span class="o">=</span> <span class="n">RTA_PAYLOAD</span><span class="p">(</span><span class="n">route_attribute</span><span class="p">);</span>
    <span class="cm">/* Is the message complete? */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rtnhp_len</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">nhptr</span><span class="p">)</span> <span class="o">||</span> 
        <span class="n">nhptr</span><span class="o">-&gt;</span><span class="n">rtnh_len</span> <span class="o">&gt;</span> <span class="n">rtnhp_len</span><span class="p">){</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* Get the size of the attributes */</span>
    <span class="n">attrlen</span> <span class="o">=</span> <span class="n">rtnhp_len</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtnexthop</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">attrlen</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Retrieve attributes */</span>
        <span class="k">struct</span> <span class="n">rtattr</span> <span class="o">*</span><span class="n">attr</span> <span class="o">=</span> <span class="n">RTNH_DATA</span><span class="p">(</span><span class="n">nhptr</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">RTA_OK</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">attrlen</span><span class="p">);</span> <span class="n">attr</span> <span class="o">=</span> <span class="n">RTA_NEXT</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">attrlen</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">rta_type</span> <span class="o">==</span> <span class="n">RTA_GATEWAY</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* Next hops from RTA_MULTIPATH are 
                 * contained in RTA_GATEWAY attributes! 
                 */</span>
                <span class="kt">uint32_t</span> <span class="n">nh</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span> <span class="n">RTA_DATA</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">"%x"</span><span class="p">,</span> <span class="n">nh</span><span class="p">);</span>  
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>The initial step is to get the <em>RTA_MULTIPATH</em>, similarly to other attributes using the RTA_DATA macro. A check for the correct size of the message follows, in case the message was not fully read from the socket. If the payload of the attribute is larger than its header, the data is retrieved using RTNH_DATA. What comes next is the most interesting part. Inside the next hop data are…guess what? More attributes! The next hop is then found in the same fashion as the <a href="https://gist.github.com/cl4u2/5204374#file-route_monitor-c-L95">gist</a>.</p>

<p>I hope this small example may help anyone looking for a way to retrieve information from the <em>RTA_MULTIPATH</em> attribute.</p>]]></content><author><name></name></author><category term="programming" /><category term="C," /><category term="networking," /><category term="programming," /><category term="Rtnetlink," /><category term="RTA_MULTIPATH" /><summary type="html"><![CDATA[I am developing an application that relies on the detection of changes to the Linux kernel route tables. For the job, one can use Rtnetlink for reading and modification of the routing tables. For example, the RTM_NEWROUTE message can be used to add a new route or read from the netlink socket, indicating a new route was added to the route table.]]></summary></entry></feed>